\contentsline {figure}{\numberline {1}{\ignorespaces 1D rod model for visualization (the length is only relevant in the $x$-dimension, all other dimensions should be assumed as zero) \relax }}{2}{figure.caption.3}%
\contentsline {figure}{\numberline {2}{\ignorespaces Discretized domain of the 1D geometry from \autoref {fig:Rod}.\relax }}{3}{figure.caption.4}%
\contentsline {figure}{\numberline {3}{\ignorespaces Discretized domain \autoref {fig:DescretizedDomain} with boundaries.\relax }}{3}{figure.caption.5}%
\contentsline {figure}{\numberline {4}{\ignorespaces Solution Matrix. Each cell represents the value of $v$ at a particular time $\tau $ and space $h$. The boundaries are not shown as they are not part of the final solution.\relax }}{4}{figure.caption.6}%
\contentsline {figure}{\numberline {5}{\ignorespaces Evaluation of \texttt {V} at a single-step $x$ (i.e. the inner for-loop) in the FTCS method. All green dots are known, and red is the unknown value being evaluated.\relax }}{6}{figure.caption.10}%
\contentsline {figure}{\numberline {6}{\ignorespaces Contents within serial directory before and after running \texttt {main.py}\relax }}{6}{figure.caption.11}%
\contentsline {figure}{\numberline {7}{\ignorespaces Comparison of the solutions obtained analytically (red) and FTCS method (dashed blue)\relax }}{7}{figure.caption.12}%
\contentsline {figure}{\numberline {8}{\ignorespaces Domain decomposition of the discretized grid \autoref {fig:DescretizedDomain} to all \texttt {ranks}. The grid is evenly distributed using \texttt {Scatter()}\relax }}{9}{figure.caption.16}%
\contentsline {figure}{\numberline {9}{\ignorespaces \texttt {create\_halo()} creates borders at each local discretization which is needed to implement the initial condition and sharing values.\relax }}{10}{figure.caption.17}%
\contentsline {figure}{\numberline {10}{\ignorespaces Sharing of bordering values at each time-step. As \texttt {rank:0} doesn't have a left neighbour, it only performs \texttt {Sendrecv()} on the right. The last \texttt {rank} would behave similarly\relax }}{11}{figure.caption.18}%
\contentsline {figure}{\numberline {11}{\ignorespaces Contents within the directory before and after running \texttt {main.py}\relax }}{12}{figure.caption.21}%
\contentsline {figure}{\numberline {12}{\ignorespaces Functions inside \texttt {main.py} to illustrate the automation\relax }}{13}{figure.caption.22}%
\contentsline {figure}{\numberline {13}{\ignorespaces Snippet from \texttt {input\_params.py} showing user input\relax }}{13}{figure.caption.23}%
\contentsline {figure}{\numberline {14}{\ignorespaces Strong Scaling Plot for $\tau =0.001$, this shows the speed up in time with increase in \texttt {size}\relax }}{14}{figure.caption.24}%
\contentsline {figure}{\numberline {15}{\ignorespaces Strong Scaling Plot for $\tau =0.0001$, this shows the speed up in time with increase in \texttt {size}\relax }}{14}{figure.caption.25}%
\contentsline {figure}{\numberline {16}{\ignorespaces Execution times of all cases in \autoref {tab:DomainDecomposition1} (top) and \autoref {tab:DomainDecomposition2} (bottom)\relax }}{15}{figure.caption.26}%
